{"version":3,"sources":["src/app.riot","node_modules/riot/riot.esm.js","src/main.js"],"names":["message","template","expressionTypes","bindingTypes","getComponent","TEXT","scope","COMPONENTS_IMPLEMENTATION_MAP","Map","DOM_COMPONENT_INSTANCE_PROPERTY","Symbol","PLUGINS_SET","Set","IS_DIRECTIVE","VALUE_ATTRIBUTE","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","globals","Object","freeze","cleanNode","node","clearChildren","childNodes","parent","children","Array","from","forEach","n","removeChild","EACH","IF","SIMPLE","TAG","SLOT","createTemplateMeta","componentTemplate","fragment","dom","cloneNode","avoidDOMInjection","append","get","start","end","before","insertBefore","ownerDocument","createDocumentFragment","appendChild","eqeq","a","b","identity","O","indexOf","moreNodes","moreStart","moreEnd","lessNodes","lessStart","lessEnd","compare","length","m","l","isReversed","futureNodes","futureEnd","currentNodes","currentStart","currentEnd","next","list","i","nextSibling","remove","range","createRange","setStartBefore","setEndAfter","deleteContents","DELETION","INSERTION","SKIP","SKIP_OND","HS","futureStart","futureChanges","currentChanges","k","minLen","link","tresh","keymap","set","idxInOld","findK","newi","oldi","prev","diff","ptr","OND","rows","cols","d","r","c","pv","cv","pd","v","outer","diffIdx","applyDiff","parentNode","currentLength","live","currentIndex","has","ktr","j","lo","hi","mid","smartDiff","domdiff","options","currentSame","futureSame","isNil","value","isTemplate","el","content","EachBinding","seal","childrenMap","root","condition","evaluate","isTemplateTag","nodes","getKey","indexName","itemName","afterPlaceholder","placeholder","mount","parentScope","update","collection","items","createPatch","newChildrenMap","batches","patch","values","unmountRedundant","fn","unmount","redundant","item","info","pop","context","map","_ref","mustFilterItem","Boolean","extendScope","_ref2","index","binding","create","key","oldItem","clone","mustMount","meta","push","delete","_ref3","document","createTextNode","assign","createDOM","IfBinding","mustUnmount","create$1","_ref4","ATTRIBUTE","EVENT","VALUE","REMOVE_ATTRIBUTE","SET_ATTIBUTE","setAllAttributes","attributes","entries","_ref5","name","attributeExpression","removeAllAttributes","keys","attribute","removeAttribute","_ref6","oldValue","getMethod","normalizeValue","eventExpression","_ref7","textExpression","_ref8","childNodeIndex","target","val","normalizeValue$1","nodeType","Node","COMMENT_NODE","textNode","replaceChild","data","valueExpression","expression","expressions","Expression","apply","type","create$2","flattenCollectionMethods","methods","reduce","acc","method","create$3","_ref9","SlotBinding","templateData","slots","find","_ref10","id","create$6","html","bindings","moveSlotInnerContent","mustRemoveRoot","slot","firstChild","createSlot","_ref11","getTag","component","slotsToMarkup","slotBindings","attr","_ref12","concat","TagBinding","tag","keepRootTag","create$4","_ref13","create$5","selector","redundantAttribute","querySelector","isSvg","owner","ownerSVGElement","createHTMLTree","createElement","innerHTML","creteSVGTree","container","svgNode","importNode","window","DOMParser","parseFromString","documentElement","createDOMTree","moveChildren","source","injectDOM","createTemplateDOM","TemplateChunk","bindingsData","Error","checkType","element","isFunction","panic","error","callOrAssign","prototype","constructor","camelToDashCase","string","replace","toLowerCase","dashToCamelCase","_","toUpperCase","defineDefaults","defaults","noop","autobindMethods","bind","defineProperty","enumerable","writable","configurable","defineProperties","properties","evaluateAttributeExpressions","domToArray","els","isArray","test","toString","call","normalize","parseNodes","names","attrs","props","prop","setAttribute","DOMattributesToObject","getName","tagName","$","ctx","querySelectorAll","CSS_BY_NAME","STYLE_NODE_SELECTOR","getStyleNode","style","head","cssManager","add","css","inject","join","curry","_len","arguments","_key","_len2","args","_key2","COMPONENT_CORE_HELPERS","$$","COMPONENT_LIFECYCLE_METHODS","shouldUpdate","onBeforeMount","onMounted","onBeforeUpdate","onUpdated","onBeforeUnmount","onUnmounted","MOCKED_TEMPLATE_INTERFACE","componentTemplateFactory","components","createComponent","exports","templateFn","createSubcomponents","componentAPI","defineComponent","state","preserveRoot","enhanceComponentAPI","evaluateProps","attributeExpressions","createAttributeBindings","updateValues","e","runPlugins","computeState","oldState","newState","addCssHook","initialProps","newProps","filter","mountComponent","componentName","compose","fns","f","g","DOM_COMPONENT_INSTANCE_PROPERTY$1","COMPONENTS_IMPLEMENTATION_MAP$1","PLUGINS_SET$1","register","unregister","keepRootElement","install","plugin","uninstall","implementation","version","__","app"],"mappings":"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","file":"main.65b0dec8.js","sourceRoot":"..","sourcesContent":["export default {\r\n  'css': null,\r\n\r\n  'exports': {\r\n    message: 'hello world'\r\n  },\r\n\r\n  'template': function(template, expressionTypes, bindingTypes, getComponent) {\r\n    return template('<p expr0><!----></p>', [{\r\n      'redundantAttribute': 'expr0',\r\n      'selector': '[expr0]',\r\n\r\n      'expressions': [{\r\n        'type': expressionTypes.TEXT,\r\n        'childNodeIndex': 0,\r\n\r\n        'evaluate': function(scope) {\r\n          return scope.message;\r\n        }\r\n      }]\r\n    }]);\r\n  },\r\n\r\n  'name': 'app'\r\n};","/* Riot v4.3.5, @license MIT */\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n      PLUGINS_SET = new Set(),\n      IS_DIRECTIVE = 'is',\n      VALUE_ATTRIBUTE = 'value',\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY,\n  PLUGINS_SET: PLUGINS_SET,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nfunction cleanNode(node) {\n  clearChildren(node, node.childNodes);\n}\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement} parent - parent node where the children will be removed\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\n\n\nfunction clearChildren(parent, children) {\n  Array.from(children).forEach(n => parent.removeChild(n));\n}\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\n\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    children: Array.from(fragment.childNodes)\n  };\n}\n/* get rid of the @ungap/essential-map polyfill */\n\n\nconst append = (get, parent, children, start, end, before) => {\n  if (end - start < 2) parent.insertBefore(get(children[start], 1), before);else {\n    const fragment = parent.ownerDocument.createDocumentFragment();\n\n    while (start < end) fragment.appendChild(get(children[start++], 1));\n\n    parent.insertBefore(fragment, before);\n  }\n};\n\nconst eqeq = (a, b) => a == b;\n\nconst identity = O => O;\n\nconst indexOf = (moreNodes, moreStart, moreEnd, lessNodes, lessStart, lessEnd, compare) => {\n  const length = lessEnd - lessStart;\n  /* istanbul ignore if */\n\n  if (length < 1) return -1;\n\n  while (moreEnd - moreStart >= length) {\n    let m = moreStart;\n    let l = lessStart;\n\n    while (m < moreEnd && l < lessEnd && compare(moreNodes[m], lessNodes[l])) {\n      m++;\n      l++;\n    }\n\n    if (l === lessEnd) return moreStart;\n    moreStart = m + 1;\n  }\n\n  return -1;\n};\n\nconst isReversed = (futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare) => {\n  while (currentStart < currentEnd && compare(currentNodes[currentStart], futureNodes[futureEnd - 1])) {\n    currentStart++;\n    futureEnd--;\n  }\n\n  return futureEnd === 0;\n};\n\nconst next = (get, list, i, length, before) => i < length ? get(list[i], 0) : 0 < i ? get(list[i - 1], -0).nextSibling : before;\n\nconst remove = (get, parent, children, start, end) => {\n  if (end - start < 2) parent.removeChild(get(children[start], -1));else {\n    const range = parent.ownerDocument.createRange();\n    range.setStartBefore(get(children[start], -1));\n    range.setEndAfter(get(children[end - 1], -1));\n    range.deleteContents();\n  }\n}; // - - - - - - - - - - - - - - - - - - -\n// diff related constants and utilities\n// - - - - - - - - - - - - - - - - - - -\n\n\nconst DELETION = -1;\nconst INSERTION = 1;\nconst SKIP = 0;\nconst SKIP_OND = 50;\n\nconst HS = (futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges) => {\n  let k = 0;\n  /* istanbul ignore next */\n\n  let minLen = futureChanges < currentChanges ? futureChanges : currentChanges;\n  const link = Array(minLen++);\n  const tresh = Array(minLen);\n  tresh[0] = -1;\n\n  for (let i = 1; i < minLen; i++) tresh[i] = currentEnd;\n\n  const keymap = new Map();\n\n  for (let i = currentStart; i < currentEnd; i++) keymap.set(currentNodes[i], i);\n\n  for (let i = futureStart; i < futureEnd; i++) {\n    const idxInOld = keymap.get(futureNodes[i]);\n\n    if (idxInOld != null) {\n      k = findK(tresh, minLen, idxInOld);\n      /* istanbul ignore else */\n\n      if (-1 < k) {\n        tresh[k] = idxInOld;\n        link[k] = {\n          newi: i,\n          oldi: idxInOld,\n          prev: link[k - 1]\n        };\n      }\n    }\n  }\n\n  k = --minLen;\n  --currentEnd;\n\n  while (tresh[k] > currentEnd) --k;\n\n  minLen = currentChanges + futureChanges - k;\n  const diff = Array(minLen);\n  let ptr = link[k];\n  --futureEnd;\n\n  while (ptr) {\n    const {\n      newi,\n      oldi\n    } = ptr;\n\n    while (futureEnd > newi) {\n      diff[--minLen] = INSERTION;\n      --futureEnd;\n    }\n\n    while (currentEnd > oldi) {\n      diff[--minLen] = DELETION;\n      --currentEnd;\n    }\n\n    diff[--minLen] = SKIP;\n    --futureEnd;\n    --currentEnd;\n    ptr = ptr.prev;\n  }\n\n  while (futureEnd >= futureStart) {\n    diff[--minLen] = INSERTION;\n    --futureEnd;\n  }\n\n  while (currentEnd >= currentStart) {\n    diff[--minLen] = DELETION;\n    --currentEnd;\n  }\n\n  return diff;\n}; // this is pretty much the same petit-dom code without the delete map part\n// https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L556-L561\n\n\nconst OND = (futureNodes, futureStart, rows, currentNodes, currentStart, cols, compare) => {\n  const length = rows + cols;\n  const v = [];\n  let d, k, r, c, pv, cv, pd;\n\n  outer: for (d = 0; d <= length; d++) {\n    /* istanbul ignore if */\n    if (d > SKIP_OND) return null;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    cv = v[d] = [];\n\n    for (k = -d; k <= d; k += 2) {\n      if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n        c = pv[pd + k + 1];\n      } else {\n        c = pv[pd + k - 1] + 1;\n      }\n\n      r = c - k;\n\n      while (c < cols && r < rows && compare(currentNodes[currentStart + c], futureNodes[futureStart + r])) {\n        c++;\n        r++;\n      }\n\n      if (c === cols && r === rows) {\n        break outer;\n      }\n\n      cv[d + k] = c;\n    }\n  }\n\n  const diff = Array(d / 2 + length / 2);\n  let diffIdx = diff.length - 1;\n\n  for (d = v.length - 1; d >= 0; d--) {\n    while (c > 0 && r > 0 && compare(currentNodes[currentStart + c - 1], futureNodes[futureStart + r - 1])) {\n      // diagonal edge = equality\n      diff[diffIdx--] = SKIP;\n      c--;\n      r--;\n    }\n\n    if (!d) break;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    k = c - r;\n\n    if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n      // vertical edge = insertion\n      r--;\n      diff[diffIdx--] = INSERTION;\n    } else {\n      // horizontal edge = deletion\n      c--;\n      diff[diffIdx--] = DELETION;\n    }\n  }\n\n  return diff;\n};\n\nconst applyDiff = (diff, get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before) => {\n  const live = new Map();\n  const length = diff.length;\n  let currentIndex = currentStart;\n  let i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        futureStart++;\n        currentIndex++;\n        break;\n\n      case INSERTION:\n        // TODO: bulk appends for sequential nodes\n        live.set(futureNodes[futureStart], 1);\n        append(get, parentNode, futureNodes, futureStart++, futureStart, currentIndex < currentLength ? get(currentNodes[currentIndex], 0) : before);\n        break;\n\n      case DELETION:\n        currentIndex++;\n        break;\n    }\n  }\n\n  i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        currentStart++;\n        break;\n\n      case DELETION:\n        // TODO: bulk removes for sequential nodes\n        if (live.has(currentNodes[currentStart])) currentStart++;else remove(get, parentNode, currentNodes, currentStart++, currentStart);\n        break;\n    }\n  }\n};\n\nconst findK = (ktr, length, j) => {\n  let lo = 1;\n  let hi = length;\n\n  while (lo < hi) {\n    const mid = (lo + hi) / 2 >>> 0;\n    if (j < ktr[mid]) hi = mid;else lo = mid + 1;\n  }\n\n  return lo;\n};\n\nconst smartDiff = (get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before) => {\n  applyDiff(OND(futureNodes, futureStart, futureChanges, currentNodes, currentStart, currentChanges, compare) || HS(futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges), get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before);\n};\n/*! (c) 2018 Andrea Giammarchi (ISC) */\n\n\nconst domdiff = (parentNode, // where changes happen\ncurrentNodes, // Array of current items/nodes\nfutureNodes, // Array of future items/nodes\noptions // optional object with one of the following properties\n//  before: domNode\n//  compare(generic, generic) => true if same generic\n//  node(generic) => Node\n) => {\n  if (!options) options = {};\n  const compare = options.compare || eqeq;\n  const get = options.node || identity;\n  const before = options.before == null ? null : get(options.before, 0);\n  const currentLength = currentNodes.length;\n  let currentEnd = currentLength;\n  let currentStart = 0;\n  let futureEnd = futureNodes.length;\n  let futureStart = 0; // common prefix\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentStart], futureNodes[futureStart])) {\n    currentStart++;\n    futureStart++;\n  } // common suffix\n\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentEnd - 1], futureNodes[futureEnd - 1])) {\n    currentEnd--;\n    futureEnd--;\n  }\n\n  const currentSame = currentStart === currentEnd;\n  const futureSame = futureStart === futureEnd; // same list\n\n  if (currentSame && futureSame) return futureNodes; // only stuff to add\n\n  if (currentSame && futureStart < futureEnd) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentStart, currentLength, before));\n    return futureNodes;\n  } // only stuff to remove\n\n\n  if (futureSame && currentStart < currentEnd) {\n    remove(get, parentNode, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  }\n\n  const currentChanges = currentEnd - currentStart;\n  const futureChanges = futureEnd - futureStart;\n  let i = -1; // 2 simple indels: the shortest sequence is a subsequence of the longest\n\n  if (currentChanges < futureChanges) {\n    i = indexOf(futureNodes, futureStart, futureEnd, currentNodes, currentStart, currentEnd, compare); // inner diff\n\n    if (-1 < i) {\n      append(get, parentNode, futureNodes, futureStart, i, get(currentNodes[currentStart], 0));\n      append(get, parentNode, futureNodes, i + currentChanges, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n      return futureNodes;\n    }\n  }\n  /* istanbul ignore else */\n  else if (futureChanges < currentChanges) {\n      i = indexOf(currentNodes, currentStart, currentEnd, futureNodes, futureStart, futureEnd, compare); // outer diff\n\n      if (-1 < i) {\n        remove(get, parentNode, currentNodes, currentStart, i);\n        remove(get, parentNode, currentNodes, i + futureChanges, currentEnd);\n        return futureNodes;\n      }\n    } // common case with one replacement for many nodes\n  // or many nodes replaced for a single one\n\n  /* istanbul ignore else */\n\n\n  if (currentChanges < 2 || futureChanges < 2) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, get(currentNodes[currentStart], 0));\n    remove(get, parentNode, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  } // the half match diff part has been skipped in petit-dom\n  // https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L391-L397\n  // accordingly, I think it's safe to skip in here too\n  // if one day it'll come out like the speediest thing ever to do\n  // then I might add it in here too\n  // Extra: before going too fancy, what about reversed lists ?\n  //        This should bail out pretty quickly if that's not the case.\n\n\n  if (currentChanges === futureChanges && isReversed(futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare)) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n    return futureNodes;\n  } // last resort through a smart diff\n\n\n  smartDiff(get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before);\n  return futureNodes;\n};\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\n\n\nfunction isNil(value) {\n  return value == null;\n}\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\n\n\nfunction isTemplate(el) {\n  return !isNil(el.content);\n}\n\nconst EachBinding = Object.seal({\n  // dynamic binding properties\n  childrenMap: null,\n  node: null,\n  root: null,\n  condition: null,\n  evaluate: null,\n  template: null,\n  isTemplateTag: false,\n  nodes: [],\n  getKey: null,\n  indexName: null,\n  itemName: null,\n  afterPlaceholder: null,\n  placeholder: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder\n    } = this;\n    const collection = this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n    const parent = placeholder.parentNode; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    if (futureNodes.length) {\n      domdiff(parent, this.nodes, futureNodes, {\n        before: placeholder,\n        node: patch(Array.from(this.childrenMap.values()), parentScope)\n      });\n    } else {\n      // remove all redundant templates\n      unmountRedundant(this.childrenMap);\n    } // trigger the mounts and the updates\n\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    unmountRedundant(this.childrenMap, parentScope);\n    this.childrenMap = new Map();\n    this.nodes = [];\n    return this;\n  }\n\n});\n/**\n * Patch the DOM while diffing\n * @param   {TemplateChunk[]} redundant - redundant tepmplate chunks\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      const {\n        template,\n        context\n      } = redundant.pop(); // notice that we pass null as last argument because\n      // the root node and its children will be removed by domdiff\n\n      template.unmount(context, parentScope, null);\n    }\n\n    return item;\n  };\n}\n/**\n * Unmount the remaining template instances\n * @param   {Map} childrenMap - map containing the children template to unmount\n * @param   {*} parentScope - scope of the parent template\n * @returns {TemplateChunk[]} collection containing the template chunks unmounted\n */\n\n\nfunction unmountRedundant(childrenMap, parentScope) {\n  return Array.from(childrenMap.values()).map((_ref) => {\n    let {\n      template,\n      context\n    } = _ref;\n    return template.unmount(context, parentScope, true);\n  });\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? Boolean(condition(context)) === false : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref2) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref2;\n  scope[itemName] = item;\n  if (indexName) scope[indexName] = index;\n  return scope;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EeachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = oldItem ? componentTemplate.el : root.cloneNode();\n    const mustMount = !oldItem;\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : {};\n\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));\n    } else {\n      componentTemplate.update(context, parentScope);\n    } // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n\n\n    if (isTemplateTag) {\n      futureNodes.push(...(meta.children || componentTemplate.children));\n    } else {\n      futureNodes.push(el);\n    } // delete the old item from the children map\n\n\n    childrenMap.delete(key); // update the children map\n\n    newChildrenMap.set(key, {\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create(node, _ref3) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref3;\n  const placeholder = document.createTextNode('');\n  const parent = node.parentNode;\n  const root = node.cloneNode();\n  parent.insertBefore(placeholder, node);\n  parent.removeChild(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n/**\n * Binding responsible for the `if` directive\n */\n\n\nconst IfBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  evaluate: null,\n  parent: null,\n  isTemplateTag: false,\n  placeholder: null,\n  template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    this.parent.insertBefore(this.placeholder, this.node);\n    this.parent.removeChild(this.node);\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    switch (true) {\n      case mustMount:\n        this.parent.insertBefore(this.node, this.placeholder);\n        this.template = this.template.clone();\n        this.template.mount(this.node, scope, parentScope);\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope);\n    return this;\n  }\n\n});\n\nfunction create$1(node, _ref4) {\n  let {\n    evaluate,\n    template\n  } = _ref4;\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    parent: node.parentNode,\n    placeholder: document.createTextNode(''),\n    template: template.createDOM(node)\n  });\n}\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\nconst SET_ATTIBUTE = 'setAttribute';\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach((_ref5) => {\n    let [name, value] = _ref5;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing all the attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, attributes) {\n  Object.keys(attributes).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref6, value, oldValue) {\n  let {\n    name\n  } = _ref6;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value);\n    } else if (oldValue) {\n      // otherwise remove all the old attributes\n      removeAllAttributes(node, oldValue);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (typeof value === 'boolean') {\n    node[name] = value;\n  }\n\n  node[getMethod(value)](name, normalizeValue(name, value));\n}\n/**\n * Get the attribute modifier method\n * @param   {*} value - if truthy we return `setAttribute` othewise `removeAttribute`\n * @returns {string} the node attribute modifier method name\n */\n\n\nfunction getMethod(value) {\n  return isNil(value) || value === false || value === '' || typeof value === 'object' ? REMOVE_ATTRIBUTE : SET_ATTIBUTE;\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  if (value === true) return name;\n  return value;\n}\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction eventExpression(node, _ref7, value) {\n  let {\n    name\n  } = _ref7;\n  node[name] = value;\n}\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {number} expression.childNodeIndex - index to find the text node to update\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction textExpression(node, _ref8, value) {\n  let {\n    childNodeIndex\n  } = _ref8;\n  const target = node.childNodes[childNodeIndex];\n  const val = normalizeValue$1(value); // replace the target if it's a placeholder comment\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode(val);\n    node.replaceChild(textNode, target);\n  } else {\n    target.data = normalizeValue$1(val);\n  }\n}\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\n\nfunction normalizeValue$1(value) {\n  return value != null ? value : '';\n}\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction valueExpression(node, expression, value) {\n  node.value = value;\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\nconst Expression = Object.seal({\n  // Static props\n  node: null,\n  value: null,\n\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    return this;\n  }\n\n});\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$2(node, data) {\n  return Object.assign({}, Expression, {}, data, {\n    node\n  });\n}\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\n\n\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref9) {\n  let {\n    expressions\n  } = _ref9;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$2(node, expression)), ['mount', 'update', 'unmount']));\n}\n\nconst SlotBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  name: null,\n  template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find((_ref10) => {\n      let {\n        id\n      } = _ref10;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    this.template = templateData && create$6(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      this.template.mount(this.node, parentScope);\n      moveSlotInnerContent(this.node);\n    }\n\n    parentNode.removeChild(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template && parentScope) {\n      this.template.update(parentScope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(parentScope, null, mustRemoveRoot);\n    }\n\n    return this;\n  }\n\n});\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLNode} slot - slot node\n * @returns {undefined} it's a void function\n */\n\nfunction moveSlotInnerContent(slot) {\n  if (slot.firstChild) {\n    slot.parentNode.insertBefore(slot.firstChild, slot);\n    moveSlotInnerContent(slot);\n  }\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} options.name - slot id\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref11) {\n  let {\n    name\n  } = _ref11;\n  return Object.assign({}, SlotBinding, {\n    node,\n    name\n  });\n}\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create$6(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref12) => {\n    let {\n      bindings\n    } = _ref12;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  evaluate: null,\n  name: null,\n  slots: null,\n  tag: null,\n  attributes: null,\n  getComponent: null,\n\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope, parentScope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this;\n  }\n\n});\n\nfunction create$4(node, _ref13) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref13;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$1,\n  [SIMPLE]: create$3,\n  [EACH]: create,\n  [TAG]: create$4,\n  [SLOT]: createSlot\n};\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {Object} binding - binding data\n * @returns {Expression} Expression object\n */\n\nfunction create$5(root, binding) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute); // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: expressions || []\n  }));\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n} // in this case a simple innerHTML is enough\n\n\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction creteSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return creteSVGTree(html, root);\n  return createHTMLTree(html, root);\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method \\_()_/\n */\n// Ignore this helper because it's needed only for svg tags\n\n/* istanbul ignore next */\n\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {HTMLFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\n\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break;\n\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break;\n\n    default:\n      el.appendChild(dom);\n  }\n}\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string} html - markup that will be injected into the root node\n * @returns {HTMLFragment} fragment that will be injected into the root node\n */\n\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  bindings: null,\n  bindingsData: null,\n  html: null,\n  isTemplateTag: false,\n  fragment: null,\n  children: null,\n  dom: null,\n  el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html);\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope); // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n\n    const {\n      fragment,\n      children,\n      avoidDOMInjection\n    } = meta; // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n\n    const {\n      parentNode\n    } = children ? children[0] : el;\n    this.isTemplateTag = isTemplate(el); // create the DOM if it wasn't created before\n\n    this.createDOM(el);\n\n    if (this.dom) {\n      // create the new template dom fragment if it want already passed in via meta\n      this.fragment = fragment || this.dom.cloneNode(true);\n    } // store root node\n    // notice that for template tags the root note will be the parent tag\n\n\n    this.el = this.isTemplateTag ? parentNode : el; // create the children array only for the <template> fragments\n\n    this.children = this.isTemplateTag ? children || Array.from(this.fragment.childNodes) : null; // inject the DOM into the el only if a fragment is available\n\n    if (!avoidDOMInjection && this.fragment) injectDOM(el, this.fragment); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$5(this.el, binding));\n    this.bindings.forEach(b => b.mount(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.el) {\n      this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));\n\n      if (mustRemoveRoot && this.el.parentNode) {\n        this.el.parentNode.removeChild(this.el);\n      } else if (mustRemoveRoot !== null) {\n        if (this.children) {\n          clearChildren(this.children[0].parentNode, this.children);\n        } else {\n          cleanNode(this.el);\n        }\n      }\n\n      this.el = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {Array} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create$6(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n\n/* eslint-disable fp/no-mutating-methods */\n/**\n * Throw an error\n * @param {string} error - error message\n * @returns {undefined} it's a IO void function\n */\n\nfunction panic(error) {\n  throw new Error(error);\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\n\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach((_ref) => {\n    let [key, value] = _ref;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n} // doese simply nothing\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\n\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return source;\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach((_ref2) => {\n    let [key, value] = _ref2;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === expressionTypes.ATTRIBUTE:\n        return Object.assign({}, acc, {}, value);\n      // value attribute\n\n      case type === expressionTypes.VALUE:\n        acc[VALUE_ATTRIBUTE] = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  shouldUpdate: noop,\n  onBeforeMount: noop,\n  onMounted: noop,\n  onBeforeUpdate: noop,\n  onUpdated: noop,\n  onBeforeUnmount: noop,\n  onUnmounted: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = {\n  update: noop,\n  mount: noop,\n  unmount: noop,\n  clone: noop,\n  createDOM: noop\n  /**\n   * Factory function to create the component templates only once\n   * @param   {Function} template - component template creation function\n   * @param   {Object} components - object containing the nested components\n   * @returns {TemplateChunk} template chunk object\n   */\n\n};\n\nfunction componentTemplateFactory(template, components) {\n  return template(create$6, expressionTypes, bindingTypes, name => {\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {string} options.css - component css\n * @param   {Function} options.template - functon that will return the dom-bindings template function\n * @param   {Object} options.exports - component interface\n * @param   {string} options.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(_ref) {\n  let {\n    css,\n    template,\n    exports,\n    name\n  } = _ref;\n  const templateFn = template ? componentTemplateFactory(template, exports ? createSubcomponents(exports.components) : {}) : MOCKED_TEMPLATE_INTERFACE;\n  return (_ref2) => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref2;\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref3) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref3;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    state: {}\n  })), Object.assign({\n    // defined during the component creation\n    slots: null,\n    root: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Evaluate the component properties either from its real attributes or from its attribute expressions\n * @param   {HTMLElement} element - component root\n * @param   {Array}  attributeExpressions - attribute values generated via createAttributeBindings\n * @returns {Object} attributes key value pairs\n */\n\nfunction evaluateProps(element, attributeExpressions) {\n  if (attributeExpressions === void 0) {\n    attributeExpressions = [];\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), {}, evaluateAttributeExpressions(attributeExpressions));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$2(node, a));\n  const binding = {};\n\n  const updateValues = method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  };\n\n  return Object.assign(binding, {\n    expressions,\n    mount: updateValues('mount'),\n    update: updateValues('update'),\n    unmount: updateValues('unmount')\n  });\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {\n    let [key, value] = _ref4;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, {}, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, 'is', name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref5) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref5;\n  const initialProps = callOrAssign(props);\n  return autobindMethods(runPlugins(defineProperties(Object.create(component), {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      this.props = Object.freeze(Object.assign({}, initialProps, {}, evaluateProps(element, this[ATTRIBUTES_KEY_SYMBOL].expressions)));\n      this.state = computeState(this.state, state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      element[DOM_COMPONENT_INSTANCE_PROPERTY] = this; // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, 'root', element); // define the slots array\n\n      defineProperty(this, 'slots', slots); // before mount lifecycle event\n\n      this.onBeforeMount(this.props, this.state); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this.onMounted(this.props, this.state);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateProps(this.root, this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this.shouldUpdate(newProps, this.props) === false) return;\n      this.props = Object.freeze(Object.assign({}, initialProps, {}, newProps));\n      this.state = computeState(this.state, state);\n      this.onBeforeUpdate(this.props, this.state);\n      this[TEMPLATE_KEY_SYMBOL].update(this, parentScope);\n      this.onUpdated(this.props, this.state);\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this.onBeforeUnmount(this.props, this.state);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, {}, preserveRoot === null ? null : !preserveRoot);\n      this.onUnmounted(this.props, this.state);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  PLUGINS_SET: PLUGINS_SET$1\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of nodes upgraded\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY$1]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY$1].unmount(keepRootElement);\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET$1.has(plugin)) panic('This plugin was already install');\n  PLUGINS_SET$1.add(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET$1.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET$1.delete(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Helpter method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return (el, props) => compose(c => c.mount(el), c => c({\n    props\n  }), createComponent)(implementation);\n}\n/** @type {string} current riot version */\n\nconst version = 'v4.3.5'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, register, uninstall, unmount, unregister, version };\n","import app from './../src/app.riot'\r\n\r\nimport {component} from 'riot'\r\n\r\ncomponent(app)(document.querySelector('#root'), {\r\n  message: 'Hello there'\r\n})"]}